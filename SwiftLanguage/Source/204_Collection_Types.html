<meta http-equiv=Content-Type content="text/html;charset=utf-8">

<blockquote>
<p>1.0 翻译：<a href="https://github.com/zqp">zqp</a> 校对：<a href="https://github.com/shinyzhu">shinyzhu</a>, <a href="https://github.com/stanzhai">stanzhai</a>, <a href="https://github.com/feiin">feiin</a></p>
</blockquote>
<blockquote>
<p>2.0 翻译+校对：<a href="https://github.com/AlanMelody">JackAlan</a></p>
</blockquote>
<h2 id="集合类型-collection-types"># 集合类型 (Collection Types)</h2>
<p>本页包含内容：</p>
<ul>
<li><a href="#mutability_of_collections">集合的可变性（Mutability of Collections）</a></li>
<li><a href="#arrays">数组（Arrays）</a></li>
<li><a href="#sets">集合（Sets）</a></li>
<li><a href="#dictionaries">字典（Dictionaries）</a></li>
</ul>
<p>Swift 语言提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本的集合类型用来存储集合数据。数组是有序数据的集。集合是无序无重复数据的集。字典是无序的键值对的集。</p>
<div class="figure">
<img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/CollectionTypes_intro_2x.png" />

</div>
<p>Swift 语言中的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>中存储的数据值类型必须明确。这意味着我们不能把不正确的数据类型插入其中。同时这也说明我们完全可以对取回值的类型非常自信。</p>
<blockquote>
<p>注意： Swift 的<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>类型被实现为泛型集合。更多关于泛型类型和集合，参见 <a href="./23_Generics.html">泛型</a>章节。</p>
</blockquote>
<p><a name="mutability_of_collections"></a></p>
<h2 id="集合的可变性">集合的可变性</h2>
<p>如果创建一个<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。如果我们把<code>Arrays</code>、<code>Sets</code>或<code>Dictionaries</code>分配成常量，那么它就是不可变的，它的大小不能被改变。</p>
<blockquote>
<p>注意： 在我们不需要改变集合大小的时候创建不可变集合是很好的习惯。如此 Swift 编译器可以优化我们创建的集合。</p>
</blockquote>
<p><a name="arrays"></a></p>
<h2 id="数组arrays">数组(Arrays)</h2>
<p>数组使用有序列表存储同一类型的多个值。相同的值可以多次出现在一个数组的不同位置中。</p>
<blockquote>
<p>注意: Swift 的<code>Array</code>类型被桥接到<code>Foundation</code>中的<code>NSArray</code>类。 更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Array</code>的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Obejective-C</em></a> 一书。</p>
</blockquote>
<p><a name="array_type_shorthand_syntax"></a></p>
<h3 id="数组的简单语法">数组的简单语法</h3>
<p>写 Swift 数组应该遵循像<code>Array&lt;T&gt;</code>这样的形式，其中<code>T</code>是这个数组中唯一允许存在的数据类型。我们也可以使用像<code>[T]</code>这样的简单语法。尽管两种形式在功能上是一样的，但是推荐较短的那种，而且在本文中都会使用这种形式来使用数组。</p>
<p><a name="creating_an_empty_array"></a></p>
<h3 id="创建一个空数组">创建一个空数组</h3>
<p>我们可以使用构造语法来创建一个由特定数据类型构成的空数组：</p>
<pre class="swift"><code>var someInts = [Int]()
print(&quot;someInts is of type [Int] with \(someInts.count) items。&quot;)
// 打印 &quot;someInts is of type [Int] with 0 items。&quot;</code></pre>
<p>注意 通过构造函数的类型，<code>someInts</code>的值类型被推断为<code>[Int]</code>。</p>
<p>或者，如果代码上下文中已经提供了类型信息，例如一个函数参数或者一个已经定义好类型的常量或者变量，我们可以使用空数组语句创建一个空数组，它的写法很简单：<code>[]</code>（一对空方括号）：</p>
<pre class="swift"><code>someInts.append(3)
// someInts 现在包含一个Int值
someInts = []
// someInts 现在是空数组，但是仍然是[Int]类型的。</code></pre>
<p><a name="creating_an_array_with_a_default_value"></a></p>
<h3 id="创建一个带有默认值的数组">创建一个带有默认值的数组</h3>
<p>Swift 中的<code>Array</code>类型还提供一个可以创建特定大小并且所有数据都被默认的构造方法。我们可以把准备加入新数组的数据项数量（<code>count</code>）和适当类型的初始值（<code>repeatedValue</code>）传入数组构造函数：</p>
<pre class="swift"><code>var threeDoubles = [Double](count: 3, repeatedValue:0.0)
// threeDoubles 是一种 [Double]数组, 等于 [0.0, 0.0, 0.0]</code></pre>
<p><a name="creating_an_array_by_adding_two_arrays_together"></a></p>
<h3 id="通过两个数组相加创建一个数组">通过两个数组相加创建一个数组</h3>
<p>我们可以使用加法操作符（<code>+</code>）来组合两种已存在的相同类型数组。新数组的数据类型会被从两个数组的数据类型中推断出来：</p>
<pre class="swift"><code>var anotherThreeDoubles = Array(count: 3, repeatedValue: 2.5)
// anotherThreeDoubles is inferred as [Double], and equals [2.5, 2.5, 2.5]

var sixDoubles = threeDoubles + anotherThreeDoubles
// sixDoubles 被推断为 [Double], 等于 [0.0, 0.0, 0.0, 2.5, 2.5, 2.5]</code></pre>
<p><a name="creating_an_array_with_an_array_literals"></a></p>
<h3 id="用字面量构造数组">用字面量构造数组</h3>
<p>我们可以使用字面量来进行数组构造，这是一种用一个或者多个数值构造数组的简单方法。字面量是一系列由逗号分割并由方括号包含的数值。 <code>[value 1, value 2, value 3]</code>。</p>
<p>下面这个例子创建了一个叫做<code>shoppingList</code>并且存储<code>String</code>的数组：</p>
<pre class="swift"><code>var shoppingList: [String] = [&quot;Eggs&quot;, &quot;Milk&quot;]
// shoppingList 已经被构造并且拥有两个初始项。</code></pre>
<p><code>shoppingList</code>变量被声明为“字符串值类型的数组“，记作<code>[String]</code>。 因为这个数组被规定只有<code>String</code>一种数据结构，所以只有<code>String</code>类型可以在其中被存取。 在这里，<code>shoppinglist</code>数组由两个<code>String</code>值（<code>&quot;Eggs&quot;</code> 和<code>&quot;Milk&quot;</code>）构造，并且由字面量定义。</p>
<blockquote>
<p>注意： <code>Shoppinglist</code>数组被声明为变量（<code>var</code>关键字创建）而不是常量（<code>let</code>创建）是因为以后可能会有更多的数据项被插入其中。</p>
</blockquote>
<p>在这个例子中，字面量仅仅包含两个<code>String</code>值。匹配了该数组的变量声明（只能包含<code>String</code>的数组），所以这个字面量的分配过程就是允许用两个初始项来构造<code>shoppinglist</code>。</p>
<p>由于 Swift 的类型推断机制，当我们用字面量构造只拥有相同类型值数组的时候，我们不必把数组的类型定义清楚。 <code>shoppinglist</code>的构造也可以这样写：</p>
<pre class="swift"><code>var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]</code></pre>
<p>因为所有字面量中的值都是相同的类型，Swift 可以推断出<code>[String]</code>是<code>shoppinglist</code>中变量的正确类型。</p>
<p><a name="accessing_and_modifying_an_array"></a></p>
<h3 id="访问和修改数组">访问和修改数组</h3>
<p>我们可以通过数组的方法和属性来访问和修改数组，或者下标语法。 还可以使用数组的只读属性<code>count</code>来获取数组中的数据项数量。</p>
<pre class="swift"><code>print(&quot;The shopping list contains \(shoppingList.count) items.&quot;)
// 输出&quot;The shopping list contains 2 items.&quot;（这个数组有2个项）</code></pre>
<p>使用布尔项<code>isEmpty</code>来作为检查<code>count</code>属性的值是否为 0 的捷径。</p>
<pre class="swift"><code>if shoppingList.isEmpty {
    print(&quot;The shopping list is empty.&quot;)
} else {
    print(&quot;The shopping list is not empty.&quot;)
}
// 打印 &quot;The shopping list is not empty.&quot;（shoppinglist不是空的）</code></pre>
<p>也可以使用<code>append</code>方法在数组后面添加新的数据项：</p>
<pre class="swift"><code>shoppingList.append(&quot;Flour&quot;)
// shoppingList 现在有3个数据项，有人在摊煎饼</code></pre>
<p>除此之外，使用加法赋值运算符（<code>+=</code>）也可以直接在数组后面添加一个或多个拥有相同类型的数据项：</p>
<pre class="swift"><code>shoppingList += [&quot;Baking Powder&quot;]
// shoppingList 现在有四项了
shoppingList += [&quot;Chocolate Spread&quot;,&quot;Cheese&quot;,&quot;Butter&quot;]
// shoppingList 现在有七项了</code></pre>
<p>可以直接使用下标语法来获取数组中的数据项，把我们需要的数据项的索引值放在直接放在数组名称的方括号中：</p>
<pre class="swift"><code>var firstItem = shoppingList[0]
// 第一项是 &quot;Eggs&quot;</code></pre>
<p>注意第一项在数组中的索引值是<code>0</code>而不是<code>1</code>。 Swift 中的数组索引总是从零开始。</p>
<p>我们也可以用下标来改变某个已有索引值对应的数据值：</p>
<pre class="swift"><code>shoppingList[0] = &quot;Six eggs&quot;
// 其中的第一项现在是 &quot;Six eggs&quot; 而不是 &quot;Eggs&quot;</code></pre>
<p>还可以利用下标来一次改变一系列数据值，即使新数据和原有数据的数量是不一样的。下面的例子把<code>&quot;Chocolate Spread&quot;</code>，<code>&quot;Cheese&quot;</code>，和<code>&quot;Butter&quot;</code>替换为<code>&quot;Bananas&quot;</code>和 <code>&quot;Apples&quot;</code>：</p>
<pre class="swift"><code>shoppingList[4...6] = [&quot;Bananas&quot;, &quot;Apples&quot;]
// shoppingList 现在有六项</code></pre>
<blockquote>
<p>注意： 不可以用下表访问的形式去在数组尾部添加新项。</p>
</blockquote>
<p>调用数组的<code>insert(_:atIndex:)</code>方法来在某个具体索引值之前添加数据项：</p>
<pre class="swift"><code>shoppingList.insert(&quot;Maple Syrup&quot;, atIndex: 0)
// shoppingList 现在有7项
// &quot;Maple Syrup&quot; 现在是这个列表中的第一项</code></pre>
<p>这次<code>insert</code>函数调用把值为<code>&quot;Maple Syrup&quot;</code>的新数据项插入列表的最开始位置，并且使用<code>0</code>作为索引值。</p>
<p>类似的我们可以使用<code>removeAtIndex</code>方法来移除数组中的某一项。这个方法把数组在特定索引值中存储的数据项移除并且返回这个被移除的数据项（我们不需要的时候就可以无视它）:</p>
<pre class="swift"><code>let mapleSyrup = shoppingList.removeAtIndex(0)
// 索引值为0的数据项被移除
// shoppingList 现在只有6项，而且不包括Maple Syrup
// mapleSyrup常量的值等于被移除数据项的值 &quot;Maple Syrup&quot;</code></pre>
<blockquote>
<p>注意： 如果我们试着对索引越界的数据进行检索或者设置新值的操作，会引发一个运行期错误。我们可以使用索引值和数组的<code>count</code>属性进行比较来在使用某个索引之前先检验是否有效。除了当<code>count</code>等于 0 时（说明这是个空数组），最大索引值一直是<code>count - 1</code>，因为数组都是零起索引。</p>
</blockquote>
<p>数据项被移除后数组中的空出项会被自动填补，所以现在索引值为<code>0</code>的数据项的值再次等于<code>&quot;Six eggs&quot;</code>:</p>
<pre class="swift"><code>firstItem = shoppingList[0]
// firstItem 现在等于 &quot;Six eggs&quot;</code></pre>
<p>如果我们只想把数组中的最后一项移除，可以使用<code>removeLast</code>方法而不是<code>removeAtIndex(_:)</code>方法来避免我们需要获取数组的<code>count</code>属性。就像后者一样，前者也会返回被移除的数据项：</p>
<pre class="swift"><code>let apples = shoppingList.removeLast()
// 数组的最后一项被移除了
// shoppingList现在只有5项，不包括cheese
// apples 常量的值现在等于&quot;Apples&quot; 字符串</code></pre>
<p><a name="iterating_over_an_array"></a></p>
<h3 id="数组的遍历">数组的遍历</h3>
<p>我们可以使用<code>for-in</code>循环来遍历所有数组中的数据项：</p>
<pre class="swift"><code>for item in shoppingList {
    print(item)
}
// Six eggs
// Milk
// Flour
// Baking Powder
// Bananas</code></pre>
<p>如果我们同时需要每个数据项的值和索引值，可以使用<code>enumerate()</code>方法来进行数组遍历。<code>enumerate()</code>返回一个由每一个数据项索引值和数据值组成的元组。我们可以把这个元组分解成临时常量或者变量来进行遍历：</p>
<pre class="swift"><code>for (index, value) in shoppingList.enumerate() {
    print(&quot;Item \(String(index + 1)): \(value)&quot;)
}
// Item 1: Six eggs
// Item 2: Milk
// Item 3: Flour
// Item 4: Baking Powder
// Item 5: Bananas</code></pre>
<p>更多关于<code>for-in</code>循环的介绍请参见<a href="05_Control_Flow.html#for_loops">for 循环</a>。</p>
<p><a name="sets"></a></p>
<h2 id="集合">集合</h2>
<p>集合(Set)用来存储相同类型并且没有确定顺序的值。当集合元素顺序不重要时或者希望确保每个元素只出现一次时可以把集合当做是数组另一形式。</p>
<blockquote>
<p>注意： Swift的<code>Set</code>类型被桥接到<code>Fundation</code>中的<code>NSSet</code>类。 关于使用<code>Fundation</code>和<code>Cocoa</code>中<code>Set</code>的知识，请看 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Objective-C</em></a>。</p>
</blockquote>
<p><a name="hash_values_for_set_types"></a></p>
<h4 id="set类型的哈希值">Set类型的哈希值</h4>
<p>为了存储在集合中，该类型必须是可哈希化的-也就是说，该类型必须提供一个方法来计算它的哈希值。一个哈希值是<code>Int</code>类型的，它和其他的对象相同，其被用来比较相等与否，比如<code>a==b</code>,它遵循的是<code>a.hashValue == b.hashValue</code>。</p>
<p>Swift 的所有基本类型(比如<code>String</code>,<code>Int</code>,<code>Double</code>和<code>Bool</code>)默认都是可哈希化的，它可以作为集合的值或者字典的键值类型。没有关联值的枚举成员值(在<a href="./08_Enumerations.html">枚举</a>有讲述)默认也是可哈希化的。</p>
<blockquote>
<p>注意： 你可以使用你自定义的类型作为集合的值或者是字典的键值类型，但你需要使你的自定义类型服从Swift标准库中的<code>Hashable</code>协议。服从<code>Hashable</code>协议的类型需要提供一个类型为<code>Int</code>的取值访问器属性<code>hashValue</code>。这个由类型的<code>hashValue</code>返回的值不需要在同一程序的不同执行周期或者不同程序之间保持相同。 因为<code>hashable</code>协议服从于<code>Equatable</code>协议，所以遵循该协议的类型也必须提供一个&quot;是否等&quot;运算符(<code>==</code>)的实现。这个<code>Equatable</code>协议需要任何遵循的<code>==</code>的实现都是一种相等的关系。也就是说，对于<code>a,b,c</code>三个值来说，<code>==</code>的实现必须满足下面三种情况：</p>
</blockquote>
<ul>
<li><code>a==a</code>(自反性)</li>
<li><code>a==b</code>意味着<code>b==a</code>(对称性)</li>
<li><code>a==b&amp;&amp;b==c</code>意味着<code>a==c</code>(传递性)</li>
</ul>
<p>关于协议遵循的更多信息，请看<a href="./22_Protocols.html">协议</a></p>
<p><a name="set_type_syntax"></a></p>
<h3 id="set类型语法">Set类型语法</h3>
<p>Swift中的<code>Set</code>类型被写为<code>Set&lt;T&gt;</code>, 这里的<code>T</code>表示<code>Set</code>中允许存储的类型，和数组不同的是，集合没有等价的简化形式。</p>
<p><a name="creating_and_initalizing_an_empty_set"></a></p>
<h3 id="创建和构造一个空的set">创建和构造一个空的Set</h3>
<p>你可以通过构造器语法创建一个特定类型的空集合：</p>
<pre class="swift"><code>var letters = Set&lt;Character&gt;()
print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;)
// 打印 &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</code></pre>
<blockquote>
<p>注意： 通过构造器，这里的<code>letters</code>变量的类型被推断为<code>Set&lt;Character&gt;</code>。</p>
</blockquote>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数组字面量创建一个空的<code>Set</code>：</p>
<pre class="swift"><code>letters.insert(&quot;a&quot;)
// letters 现在含有1个Character类型的值
letters = []
// letters 现在是一个空的Set, 但是它依然是 Set&lt;Character&gt; 类型</code></pre>
<p><a name="creating_a_set_with_an_array_literal"></a></p>
<h3 id="用数组字面量创建集合">用数组字面量创建集合</h3>
<p>你可以使用数组字面量来构造集合，并且可以使用简化形式写一个或者多个值作为集合元素。</p>
<p>下面的例子创建一个称之为<code>favoriteGenres</code>的集合来存储<code>String</code>类型的值：</p>
<pre class="swift"><code>var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]
// favoriteGenres被构造成含有三个初始值的集合</code></pre>
<p>这个<code>favoriteGenres</code>变量被声明为“一个<code>String</code>值的集合”，写为<code>Set&lt;String&gt;</code>。由于这个特定的集合含有指定<code>String</code>类型的值，所以它只允许存储<code>String</code>类型值。这里的<code>favoriteGenres</code>变量有三个<code>String</code>类型的初始值(&quot;<code>Rock</code>&quot;,&quot;<code>Classical</code>&quot;和&quot;<code>Hip hop</code>&quot;)，并以数组字面量的方式出现。</p>
<blockquote>
<p>注意： <code>favoriteGenres</code>被声明为一个变量(拥有<code>var</code>标示符)而不是一个常量(拥有<code>let</code>标示符),因为它里面的元素将会在下面的例子中被增加或者移除。</p>
</blockquote>
<p>一个<code>Set</code>类型不能从数组中字面量中独立地被推断出来，因此<code>Set</code>类型必须显式声明。然而，由于Swift的类型推导功能，如果你想使用一个数组字面量构造一个Set并且该数组字面量中的所有元素类型相同，那么你无须写出<code>Set</code>的具体类型。<code>favoriteGenres</code>的构造形式可以采用简化的方式代替：</p>
<pre class="swift"><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></pre>
<p>由于数组字面量中的所有元素类型相同，Swift可以推断出<code>Set&lt;String&gt;</code>作为<code>favoriteGenres</code>变量的正确类型。</p>
<p><a name="accesing_and_modifying_a_set"></a></p>
<h3 id="访问和修改一个set">访问和修改一个Set</h3>
<p>你可以通过<code>Set</code>的属性和方法来访问和修改一个<code>Set</code>.</p>
<p>为了找出一个<code>Set</code>中元素的数量，可以使用其只读属性<code>count</code>:</p>
<pre class="swift"><code>print(&quot;I have \(favoriteGenres.count) favorite music genres.&quot;)
// 打印 &quot;I have 3 favorite music genres.&quot;</code></pre>
<p>使用布尔属性<code>isEmpty</code>作为一个缩写形式去检查<code>count</code>属性是否为<code>0</code>:</p>
<pre class="swift"><code>if favoriteGenres.isEmpty {
    print(&quot;As far as music goes, I&#39;m not picky.&quot;)
} else {
    print(&quot;I have particular music preferences.&quot;)
}
// 打印 &quot;I have particular music preferences.&quot;</code></pre>
<p>你可以通过调用<code>Set</code>的<code>insert(_:)</code>方法来添加一个新元素：</p>
<pre class="swift"><code>favoriteGenres.insert(&quot;Jazz&quot;)
// favoriteGenres 现在包含4个元素</code></pre>
<p>你可以通过调用<code>Set</code>的<code>remove(_:)</code>方法去删除一个元素，如果该值是该<code>Set</code>的一个元素则删除该元素并且返回被删除的元素值，否认如果该<code>Set</code>不包含该值，则返回<code>nil</code>。另外，<code>Set</code>中的所有元素可以通过它的<code>removeAll()</code>方法删除。</p>
<pre class="swift"><code>if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) {
    print(&quot;\(removedGenre)? I&#39;m over it.&quot;)
} else {
    print(&quot;I never much cared for that.&quot;)
}
// 打印 &quot;Rock? I&#39;m over it.&quot;</code></pre>
<p>使用<code>contains(_:)</code>方法去检查<code>Set</code>中是否包含一个特定的值。</p>
<pre class="swift"><code>if favoriteGenres.contains(&quot;Funk&quot;) {
    print(&quot;I get up on the good foot.&quot;)
} else {
    print(&quot;It&#39;s too funky in here.&quot;)
}
// 打印 &quot;It&#39;s too funky in here.&quot;</code></pre>
<p><a name="iterating_over_a_set"></a></p>
<h3 id="遍历一个set">遍历一个Set</h3>
<p>你可以在一个<code>for-in</code>循环中遍历一个<code>Set</code>中的所有值。</p>
<pre class="swift"><code>for genre in favoriteGenres {
    print(&quot;\(genre)&quot;)
}
// Classical
// Jazz
// Hip hop</code></pre>
<p>更多关于<code>for-in</code>循环信息，参见<a href="./05_Control_Flow.html#for_loops">For循环</a>。</p>
<p>Swift 的<code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个<code>Set</code>中值可以使用<code>sort()</code>方法，它将根据提供的序列返回一个排序的集合.</p>
<pre class="swift"><code>for genre in favoriteGenres.sort() {
    print(&quot;\(genre)&quot;)
}
// prints &quot;Classical&quot;
// prints &quot;Hip hop&quot;
// prints &quot;Jazz</code></pre>
<p><a name="performing_set_operations"></a></p>
<h3 id="完成集合操作">完成集合操作</h3>
<p>你可以高效的完成<code>Set</code>的一些基本操作，比如把两个集合组合到一起，判断两个集合共有元素，或者判断两个集合是否全包含，部分包含或者不相交。</p>
<p><a name="fundamental_set_operations"></a></p>
<h4 id="基本集合操作">基本集合操作</h4>
<p>下面的插图描述了两个集合-<code>a</code>和<code>b</code>-以及通过阴影部分的区域显示集合各种操作的结果。</p>
<div class="figure">
<img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setVennDiagram_2x.png" />

</div>
<ul>
<li>使用<code>intersect(_:)</code>方法根据两个集合中都包含的值创建的一个新的集合。</li>
<li>使用<code>exclusiveOr(_:)</code>方法根据值在一个集合中但不在两个集合中的值创建一个新的集合。</li>
<li>使用<code>union(_:)</code>方法根据两个集合的值创建一个新的集合。</li>
<li>使用<code>subtract(_:)</code>方法根据不在该集合中的值创建一个新的集合。</li>
</ul>
<pre class="swift"><code>let oddDigits: Set = [1, 3, 5, 7, 9]
let evenDigits: Set = [0, 2, 4, 6, 8]
let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]
oddDigits.union(evenDigits).sort()
// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
oddDigits.intersect(evenDigits).sort()
// []
oddDigits.subtract(singleDigitPrimeNumbers).sort()
// [1, 9]
oddDigits.exclusiveOr(singleDigitPrimeNumbers).sort()
// [1, 2, 9]</code></pre>
<p><a name="set_membership_and_equality"></a></p>
<h4 id="集合成员关系和相等">集合成员关系和相等</h4>
<p>下面的插图描述了三个集合-<code>a</code>,<code>b</code>和<code>c</code>,以及通过悬浮区域表述集合间共享的元素。Set <code>a</code>是Set<code>b</code>的父集合，因为<code>a</code>包含了<code>b</code>中所有的元素，相反的，Set <code>b</code>是<code>a</code>的子集合，因为属于<code>b</code>的元素也被<code>a</code>包含。Set <code>b</code>和Set <code>c</code>彼此不关联，因为它们之间没有共同的元素。</p>
<div class="figure">
<img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/setEulerDiagram_2x.png" />

</div>
<ul>
<li>使用“是否等”运算符(<code>==</code>)来判断两个集合是否包含全部相同的值。</li>
<li>使用<code>isSubsetOf(_:)</code>方法来判断一个集合中的值是否也被包含在另外一个集合中。</li>
<li>使用<code>isSupersetOf(_:)</code>方法来判断一个集合中包含的值是另一个集合中所有的值。</li>
<li>使用<code>isStrictSubsetOf(_:)</code>或者<code>isStrictSupersetOf(_:)</code>方法来判断一个集合是否是另外一个集合的子集合或者父集合并且和特定集合不相等。</li>
<li>使用<code>isDisjointWith(_:)</code>方法来判断两个结合是否不含有相同的值。</li>
</ul>
<pre class="swift"><code>let houseAnimals: Set = [&quot;🐶&quot;, &quot;🐱&quot;]
let farmAnimals: Set = [&quot;🐮&quot;, &quot;🐔&quot;, &quot;🐑&quot;, &quot;🐶&quot;, &quot;🐱&quot;]
let cityAnimals: Set = [&quot;🐦&quot;, &quot;🐭&quot;]
houseAnimals.isSubsetOf(farmAnimals)
// true
farmAnimals.isSupersetOf(houseAnimals)
// true
farmAnimals.isDisjointWith(cityAnimals)
// true</code></pre>
<p><a name="dictionaries"></a></p>
<h2 id="字典">字典</h2>
<p>字典是一种存储多个相同类型的值的容器。每个值（value）都关联唯一的键（key），键作为字典中的这个值数据的标识符。和数组中的数据项不同，字典中的数据项并没有具体顺序。我们在需要通过标识符（键）访问数据的时候使用字典，这种方法很大程度上和我们在现实世界中使用字典查字义的方法一样。</p>
<blockquote>
<p>注意： Swiftly 的<code>Dictionary</code> 类型被桥接到Foundation的<code>NSDictionary</code>类。 更多关于在<code>Foundation</code>和<code>Cocoa</code>中使用<code>Dictionary</code>类型的信息，参见 <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216"><em>Using Swift with Cocoa and Obejective-C</em></a> 一书。</p>
</blockquote>
<p><a name="dictionary_type_shorthand_syntax"></a></p>
<h2 id="字典类型快捷语法">字典类型快捷语法</h2>
<!--more
Swift 的字典使用时需要具体规定可以存储键和值类型。不同于 Objective-C 的`NSDictionary`和`NSMutableDictionary` 类可以使用任何类型的对象来作键和值并且不提供任何关于这些对象的本质信息。在 Swift 中，在某个特定字典中可以存储的键和值必须提前定义清楚，方法是通过显性类型标注或者类型推断。
-->
<p>Swift 的字典使用<code>Dictionary&lt;Key, Value&gt;</code>定义，其中<code>Key</code>是字典中键的数据类型，<code>Value</code>是字典中对应于这些键所存储值的数据类型。</p>
<blockquote>
<p>注意： 一个字典的<code>Key</code>类型必须遵循<code>Hashable</code>协议，就像<code>Set</code>的值类型。</p>
</blockquote>
<p>我们也可以用<code>[Key: Value]</code>这样快捷的形式去创建一个字典类型。虽然这俩种形式功能上相同，但是后者是首选，并且这本指导书涉及到字典类型时通篇采用后者。</p>
<!--more
`KeyType`的唯一限制就是可哈希的，这样可以保证它是独一无二的，所有的 Swift 基本类型（例如`String`，`Int`， `Double`和`Bool`）都是默认可哈希的，并且所有这些类型都可以在字典中当做键使用。未关联值的枚举成员（参见[枚举](08_Enumerations.html)）也是默认可哈希的。
-->
<p><a name="creating_an_empty_dictionary"></a></p>
<h3 id="创建一个空字典">创建一个空字典</h3>
<p>我们可以像数组一样使用构造语法创建一个拥有确定类型的空字典：</p>
<pre class="swift"><code>var namesOfIntegers = [Int: String]()
// namesOfIntegers 是一个空的 [Int: String] 字典</code></pre>
<p>这个例子创建了一个<code>[Int: String]</code>类型的空字典来储存英语对整数的命名。它的键是<code>Int</code>型，值是<code>String</code>型。</p>
<p>如果上下文已经提供了信息类型，我们可以使用空字典字面量来创建一个空字典，记作<code>[:]</code>（中括号中放一个冒号）：</p>
<pre class="swift"><code>namesOfIntegers[16] = &quot;sixteen&quot;
// namesOfIntegers 现在包含一个键值对
namesOfIntegers = [:]
// namesOfIntegers 又成为了一个 Int, String类型的空字典</code></pre>
<p><a name="creating_a_dictionary_with_a_dictionary_literal"></a></p>
<h2 id="字典字面量">字典字面量</h2>
<p>我们可以使用字典字面量来构造字典，这和我们刚才介绍过的数组字面量拥有相似语法。字典字面量是一种将写一个或多个键值对作<code>Dictionary</code>集合的快捷途径。</p>
<p>一个键值对是一个<code>key</code>和一个<code>value</code>的结合体。在字典字面量中，每一个键值对的键和值都由冒号分割。这些键值对构成一个列表，其中这些键值对由方括号包含、由逗号分割：</p>
<pre class="swift"><code>[key 1: value 1, key 2: value 2, key 3: value 3]</code></pre>
<p>下面的例子创建了一个存储国际机场名称的字典。在这个字典中键是三个字母的国际航空运输相关代码，值是机场名称：</p>
<pre class="swift"><code>var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></pre>
<p><code>airports</code>字典被声明为一种 <code>[String: String]</code>类型，这意味着这个字典的键和值都是<code>String</code>类型。</p>
<blockquote>
<p>注意： <code>airports</code>字典被声明为变量（用<code>var</code>关键字）而不是常量（<code>let</code>关键字）因为后来更多的机场信息会被添加到这个示例字典中。</p>
</blockquote>
<p><code>airports</code>字典使用字典字面量初始化，包含两个键值对。第一对的键是<code>YYZ</code>，值是<code>Toronto Pearson</code>。第二对的键是<code>DUB</code>，值是<code>Dublin</code>。</p>
<p>这个字典语句包含了两个<code>String: String</code>类型的键值对。它们对应<code>airports</code>变量声明的类型（一个只有<code>String</code>键和<code>String</code>值的字典）所以这个字典字面量的任务是构造拥有两个初始数据项的<code>airport</code>字典。</p>
<p>和数组一样，我们在用字典字面量构造字典时，如果它的键和值都有各自一致的类型，那么就不必写出字典的类型。 <code>airports</code>的也可以用这种方法简短定义：</p>
<pre class="swift"><code>var airports = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]</code></pre>
<p>因为这个语句中所有的键和值都各自拥有相同的数据类型，Swift 可以推断出<code>Dictionary&lt;String, String&gt;</code>是<code>airports</code>字典的正确类型。</p>
<p><a name="accessing_and_modifying_a_dictionary"></a></p>
<h3 id="读取和修改字典">读取和修改字典</h3>
<p>我们可以通过字典的方法和属性来读取和修改字典，或者通过使用下标语法。</p>
<p>和数组一样，我们可以通过字典的只读属性<code>count</code>来获取某个字典的数据项数量：</p>
<pre class="swift"><code>print(&quot;The dictionary of airports contains \(airports.count) items.&quot;)
// 打印 &quot;The dictionary of airports contains 2 items.&quot;（这个字典有两个数据项）</code></pre>
<p>使用布尔属性<code>isEmpty</code>来快捷的检查字典的<code>count</code>属性是否等于0。</p>
<pre class="swift"><code>if airports.isEmpty {
    print(&quot;The airports dictionary is empty.&quot;)
} else {
    print(&quot;The airports dictionary is not empty.&quot;)
}
// 打印 &quot;The airports dictionary is not empty.&quot;</code></pre>
<p>我们也可以在字典中使用下标语法来添加新的数据项。可以使用一个合适类型的键值作为下标索引，并且分配新的合适类型的值：</p>
<pre class="swift"><code>airports[&quot;LHR&quot;] = &quot;London&quot;
// airports 字典现在有三个数据项</code></pre>
<p>我们也可以使用下标语法来改变特定键对应的值：</p>
<pre class="swift"><code>airports[&quot;LHR&quot;] = &quot;London Heathrow&quot;
// &quot;LHR&quot;对应的值 被改为 &quot;London Heathrow</code></pre>
<p>作为另一种下标方法，字典的<code>updateValue(_:forKey:)</code>方法可以设置或者更新特定键对应的值。就像上面所示的下标示例，<code>updateValue(_:forKey:)</code>方法在这个键不存在对应值的时候会设置新值或者在存在时更新已存在的值。和上面的下标方法不同的，<code>updateValue(_:forKey:)</code>这个方法返回更新值之前的原值。这样使得我们可以检查更新是否成功。</p>
<p><code>updateValue(_:forKey:)</code>函数会返回包含一个字典值类型的可选值。举例来说：对于存储<code>String</code>值的字典，这个函数会返回一个<code>String?</code>或者“可选 <code>String</code>”类型的值。</p>
<p>如果有值存在于更新前，则这个可选值包含了旧值，否则它将会是<code>nil</code>。</p>
<pre class="swift"><code>if let oldValue = airports.updateValue(&quot;Dublin Airport&quot;, forKey: &quot;DUB&quot;) {
    print(&quot;The old value for DUB was \(oldValue).&quot;)
}
// 输出 &quot;The old value for DUB was Dublin.&quot;</code></pre>
<p>我们也可以使用下标语法来在字典中检索特定键对应的值。因为有可能请求的键没有对应的值存在，字典的下标访问会返回一个字典值类型的可选值。如果这个字典包含请求键所对应的值，下标会返回一个包含这个存在值的可选值，否则将返回<code>nil</code>：</p>
<pre class="swift"><code>if let airportName = airports[&quot;DUB&quot;] {
    print(&quot;The name of the airport is \(airportName).&quot;)
} else {
    print(&quot;That airport is not in the airports dictionary.&quot;)
}
// 打印 &quot;The name of the airport is Dublin Airport.&quot;</code></pre>
<p>我们还可以使用下标语法来通过给某个键的对应值赋值为<code>nil</code>来从字典里移除一个键值对：</p>
<pre class="swift"><code>airports[&quot;APL&quot;] = &quot;Apple Internation&quot;
// &quot;Apple Internation&quot;不是真的 APL机场, 删除它
airports[&quot;APL&quot;] = nil
// APL现在被移除了</code></pre>
<p>此外，<code>removeValueForKey(_:)</code>方法也可以用来在字典中移除键值对。这个方法在键值对存在的情况下会移除该键值对并且返回被移除的值或者在没有值的情况下返回<code>nil</code>：</p>
<pre class="swift"><code>if let removedValue = airports.removeValueForKey(&quot;DUB&quot;) {
    print(&quot;The removed airport&#39;s name is \(removedValue).&quot;)
} else {
    print(&quot;The airports dictionary does not contain a value for DUB.&quot;)
}
// prints &quot;The removed airport&#39;s name is Dublin Airport.&quot;</code></pre>
<p><a name="iterating_over_a_dictionary"></a></p>
<h3 id="字典遍历">字典遍历</h3>
<p>我们可以使用<code>for-in</code>循环来遍历某个字典中的键值对。每一个字典中的数据项都以<code>(key, value)</code>元组形式返回，并且我们可以使用临时常量或者变量来分解这些元组：</p>
<pre class="swift"><code>for (airportCode, airportName) in airports {
    print(&quot;\(airportCode): \(airportName)&quot;)
}
// YYZ: Toronto Pearson
// LHR: London Heathrow</code></pre>
<p>更多关于<code>for-in</code>循环的信息，参见<a href="./05_Control_Flow.html#for_loops">For 循环</a>。</p>
<p>通过访问<code>keys</code>或者<code>values</code>属性，我们也可以遍历字典的键或者值。</p>
<pre class="swift"><code>for airportCode in airports.keys {
    print(&quot;Airport code: \(airportCode)&quot;)
}
// Airport code: YYZ
// Airport code: LHR

for airportName in airports.values {
    print(&quot;Airport name: \(airportName)&quot;)
}
// Airport name: Toronto Pearson
// Airport name: London Heathrow</code></pre>
<p>如果我们只是需要使用某个字典的键集合或者值集合来作为某个接受<code>Array</code>实例 API 的参数，可以直接使用<code>keys</code>或者<code>values</code>属性直接构造一个新数组：</p>
<pre class="swift"><code>let airportCodes = Array(airports.keys)
// airportCodes is [&quot;YYZ&quot;, &quot;LHR&quot;]

let airportNames = Array(airports.values)
// airportNames is [&quot;Toronto Pearson&quot;, &quot;London Heathrow&quot;]</code></pre>
<p>Swift 的字典类型是无序集合类型。为了以特定的顺序遍历字典的键或值，可以对字典的<code>keys</code>或<code>values</code>属性使用<code>sort()</code>方法。</p>
<meta charset="UTF-8">
<link rel="stylesheet" href="default.css">
<script src="highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

